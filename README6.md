# ğŸ”¬ Scheme è§£é‡Šå™¨ eval åŠŸèƒ½è¾¹ç•Œæƒ…å†µåˆ†æ

æœ¬æ–‡æ¡£è¯¦ç»†åˆ†ææ¯ä¸ªè¡¨è¾¾å¼ç±»å‹åœ¨æ±‚å€¼æ—¶çš„è¾¹ç•Œæƒ…å†µã€è¯­æ³•å½¢å¼å’Œè¾“å‡ºç»“æœã€‚

## ğŸ“‹ ç›®å½•
1. [å­—é¢é‡è¡¨è¾¾å¼](#å­—é¢é‡è¡¨è¾¾å¼)
2. [å˜é‡å’Œå¼•ç”¨](#å˜é‡å’Œå¼•ç”¨)
3. [ç®—æœ¯è¿ç®—è¡¨è¾¾å¼](#ç®—æœ¯è¿ç®—è¡¨è¾¾å¼)
4. [æ¯”è¾ƒè¿ç®—è¡¨è¾¾å¼](#æ¯”è¾ƒè¿ç®—è¡¨è¾¾å¼)
5. [é€»è¾‘è¿ç®—è¡¨è¾¾å¼](#é€»è¾‘è¿ç®—è¡¨è¾¾å¼)
6. [æ§åˆ¶æµè¡¨è¾¾å¼](#æ§åˆ¶æµè¡¨è¾¾å¼)
7. [ç»‘å®šå’Œå®šä¹‰è¡¨è¾¾å¼](#ç»‘å®šå’Œå®šä¹‰è¡¨è¾¾å¼)
8. [å‡½æ•°ç›¸å…³è¡¨è¾¾å¼](#å‡½æ•°ç›¸å…³è¡¨è¾¾å¼)
9. [åˆ—è¡¨æ“ä½œè¡¨è¾¾å¼](#åˆ—è¡¨æ“ä½œè¡¨è¾¾å¼)
10. [ç±»å‹è°“è¯è¡¨è¾¾å¼](#ç±»å‹è°“è¯è¡¨è¾¾å¼)
11. [ç³»ç»Ÿæ§åˆ¶è¡¨è¾¾å¼](#ç³»ç»Ÿæ§åˆ¶è¡¨è¾¾å¼)

---

## å­—é¢é‡è¡¨è¾¾å¼

### 1. Fixnum::eval() - æ•´æ•°å­—é¢é‡

#### è¯­æ³•å½¢å¼
```scheme
42      ; æ­£æ•´æ•°
-17     ; è´Ÿæ•´æ•°
0       ; é›¶
```

#### è¾¹ç•Œæƒ…å†µ
| æƒ…å†µ | è¾“å…¥ | è¾“å‡º | è¯´æ˜ |
|------|------|------|------|
| **æœ€å°æ•´æ•°** | `INT_MIN` | `IntegerV(INT_MIN)` | ç³»ç»Ÿæ”¯æŒçš„æœ€å°æ•´æ•° |
| **æœ€å¤§æ•´æ•°** | `INT_MAX` | `IntegerV(INT_MAX)` | ç³»ç»Ÿæ”¯æŒçš„æœ€å¤§æ•´æ•° |
| **é›¶å€¼** | `0` | `IntegerV(0)` | ç‰¹æ®Šæ•°å€¼é›¶ |
| **æ­£å¸¸æ•´æ•°** | `42` | `IntegerV(42)` | æ™®é€šæ­£æ•´æ•° |
| **è´Ÿæ•´æ•°** | `-17` | `IntegerV(-17)` | æ™®é€šè´Ÿæ•´æ•° |

#### å®ç°ä»£ç 
```cpp
Value Fixnum::eval(Assoc &e) {
    return IntegerV(n);  // ç›´æ¥è¿”å›æ•´æ•°å€¼å¯¹è±¡
}
```

#### ä¸ä¼šå¤±è´¥çš„æƒ…å†µ
- æ•´æ•°å­—é¢é‡æ±‚å€¼æ°¸è¿œæˆåŠŸ
- ä¸ä¾èµ–ç¯å¢ƒçŠ¶æ€
- ä¸è¿›è¡Œä»»ä½•è®¡ç®—æˆ–æ£€æŸ¥

---

### 2. StringExpr::eval() - å­—ç¬¦ä¸²å­—é¢é‡

#### è¯­æ³•å½¢å¼
```scheme
"hello world"    ; åŸºæœ¬å­—ç¬¦ä¸²
""              ; ç©ºå­—ç¬¦ä¸²
"say \"hi\""    ; åŒ…å«è½¬ä¹‰å­—ç¬¦
"line1\nline2"  ; åŒ…å«æ¢è¡Œç¬¦
```

#### è¾¹ç•Œæƒ…å†µ
| æƒ…å†µ | è¾“å…¥ | è¾“å‡º | è¯´æ˜ |
|------|------|------|------|
| **ç©ºå­—ç¬¦ä¸²** | `""` | `StringV("")` | é•¿åº¦ä¸º0çš„å­—ç¬¦ä¸² |
| **å•å­—ç¬¦** | `"a"` | `StringV("a")` | æœ€çŸ­éç©ºå­—ç¬¦ä¸² |
| **é•¿å­—ç¬¦ä¸²** | `"very long..."` | `StringV("very long...")` | ä»»æ„é•¿åº¦å­—ç¬¦ä¸² |
| **è½¬ä¹‰å­—ç¬¦** | `"hello\nworld"` | `StringV("hello\nworld")` | åŒ…å«ç‰¹æ®Šå­—ç¬¦ |
| **å¼•å·å­—ç¬¦ä¸²** | `"say \"hi\""` | `StringV("say \"hi\"")` | åŒ…å«å†…åµŒå¼•å· |

#### å®ç°ä»£ç 
```cpp
Value StringExpr::eval(Assoc &e) {
    return StringV(s);  // ç›´æ¥è¿”å›å­—ç¬¦ä¸²å€¼å¯¹è±¡
}
```

---

### 3. True::eval() / False::eval() - å¸ƒå°”å­—é¢é‡

#### è¯­æ³•å½¢å¼
```scheme
#t    ; çœŸå€¼
#f    ; å‡å€¼
```

#### è¾¹ç•Œæƒ…å†µ
| æƒ…å†µ | è¾“å…¥ | è¾“å‡º | è¯´æ˜ |
|------|------|------|------|
| **çœŸå€¼** | `#t` | `BooleanV(true)` | å¸ƒå°”çœŸå€¼ |
| **å‡å€¼** | `#f` | `BooleanV(false)` | å¸ƒå°”å‡å€¼ |

#### å®ç°ä»£ç 
```cpp
Value True::eval(Assoc &e) {
    return BooleanV(true);
}

Value False::eval(Assoc &e) {
    return BooleanV(false);
}
```

---

## å˜é‡å’Œå¼•ç”¨

### 4. Var::eval() - å˜é‡æ±‚å€¼

#### è¯­æ³•å½¢å¼
```scheme
x           ; ç”¨æˆ·å®šä¹‰å˜é‡
+           ; åŸè¯­å‡½æ•°å
undefined   ; æœªå®šä¹‰å˜é‡ï¼ˆé”™è¯¯ï¼‰
```

#### è¾¹ç•Œæƒ…å†µ
| æƒ…å†µ | è¾“å…¥ | è¾“å‡º | é”™è¯¯ä¿¡æ¯ |
|------|------|------|----------|
| **ç”¨æˆ·å˜é‡å­˜åœ¨** | ç¯å¢ƒä¸­å·²å®šä¹‰çš„å˜é‡ | å˜é‡çš„å€¼ | - |
| **åŸè¯­å‡½æ•°** | `+`, `-`, `*`, `/` ç­‰ | åŠ¨æ€åˆ›å»ºçš„`ProcedureV` | - |
| **å˜é‡æœªå®šä¹‰** | ç¯å¢ƒä¸­ä¸å­˜åœ¨çš„å˜é‡ | - | `"undefined variable"` |
| **éæ³•å˜é‡å** | ä»¥æ•°å­—å¼€å¤´ | - | `"Wrong variable name"` |
| **åŒ…å«#å­—ç¬¦** | `x#y` | - | `"undefined variable"` |
| **ç©ºå˜é‡å** | `""` | - | `"Wrong variable name"` |

#### å®ç°ä»£ç 
```cpp
Value Var::eval(Assoc &e) {
    // éªŒè¯å˜é‡åæ ¼å¼
    if ((x.empty()) || (std::isdigit(x[0]) || x[0] == '.' || x[0] == '@')) 
        throw RuntimeError("Wrong variable name");
    for (int i = 0; i < x.size(); i++) {
        if (x[i] == '#') {
            throw(RuntimeError("undefined variable"));
        }
    }

    // åœ¨ç¯å¢ƒä¸­æŸ¥æ‰¾å˜é‡
    Value matched_value = find(x, e);
    if (matched_value.get() == nullptr) {
        // æ£€æŸ¥æ˜¯å¦ä¸ºåŸè¯­å‡½æ•°
        if (primitives.count(x)) {
            // åŠ¨æ€åˆ›å»ºåŸè¯­å‡½æ•°çš„ Procedure åŒ…è£…
            return create_primitive_procedure(x);
        } else {
            throw(RuntimeError("undefined variable"));
        }
    }
    return matched_value;
}
```

#### åŸè¯­å‡½æ•°åŠ¨æ€åŒ…è£…
```cpp
// æ”¯æŒçš„åŸè¯­å‡½æ•°ç±»å‹
case E_PLUS:    { exp = new Plus(new Var("parm1"), new Var("parm2")); break; }
case E_MINUS:   { exp = new Minus(new Var("parm1"), new Var("parm2")); break; }
case E_MUL:     { exp = new Mult(new Var("parm1"), new Var("parm2")); break; }
case E_DIV:     { exp = new Div(new Var("parm1"), new Var("parm2")); break; }
// ... æ›´å¤šåŸè¯­å‡½æ•°
```

---

### 5. Quote::eval() - å¼•ç”¨è¡¨è¾¾å¼

#### è¯­æ³•å½¢å¼
```scheme
'symbol           ; å¼•ç”¨ç¬¦å·
'(1 2 3)         ; å¼•ç”¨åˆ—è¡¨
'"hello"         ; å¼•ç”¨å­—ç¬¦ä¸²
'#t              ; å¼•ç”¨å¸ƒå°”å€¼
'()              ; å¼•ç”¨ç©ºåˆ—è¡¨
'(a . b)         ; å¼•ç”¨ç‚¹å¯¹
```

#### è¾¹ç•Œæƒ…å†µ
| æƒ…å†µ | è¾“å…¥è¯­æ³• | è¾“å‡º | è¯´æ˜ |
|------|----------|------|------|
| **ç¬¦å·** | `'hello` | `SymbolV("hello")` | ç¬¦å·å€¼ |
| **æ•°å­—** | `'42` | `IntegerV(42)` | æ•°å­—å€¼ |
| **å­—ç¬¦ä¸²** | `'"text"` | `StringV("text")` | å­—ç¬¦ä¸²å€¼ |
| **å¸ƒå°”å€¼** | `'#t` | `BooleanV(true)` | å¸ƒå°”å€¼ |
| **ç©ºåˆ—è¡¨** | `'()` | `NullV()` | ç©ºåˆ—è¡¨ |
| **å•å…ƒç´ åˆ—è¡¨** | `'(a)` | `PairV(SymbolV("a"), NullV())` | å•å…ƒç´ åˆ—è¡¨ |
| **å¤šå…ƒç´ åˆ—è¡¨** | `'(1 2 3)` | é€’å½’æ„å»ºçš„å¯¹å¶é“¾ | æ­£å¸¸åˆ—è¡¨ |
| **ç‚¹å¯¹** | `'(a . b)` | `PairV(SymbolV("a"), SymbolV("b"))` | ä¸è§„èŒƒåˆ—è¡¨ |
| **åµŒå¥—ç»“æ„** | `'((a b) c)` | åµŒå¥—çš„å¯¹å¶ç»“æ„ | å¤æ‚åµŒå¥— |

#### å®ç°ä»£ç 
```cpp
Value Quote::eval(Assoc& e) {
    if (dynamic_cast<TrueSyntax*>(s.get())) 
        return BooleanV(true);
    else if (dynamic_cast<FalseSyntax*>(s.get())) 
        return BooleanV(false);
    else if (dynamic_cast<Number*>(s.get()))
        return IntegerV(dynamic_cast<Number*>(s.get())->n);
    else if (dynamic_cast<SymbolSyntax*>(s.get())) 
        return SymbolV(dynamic_cast<SymbolSyntax*>(s.get())->s);
    else if (dynamic_cast<StringSyntax*>(s.get())) 
        return StringV(dynamic_cast<StringSyntax*>(s.get())->s);
    else if (dynamic_cast<List*>(s.get())) {
        return convert_list_to_pairs(s);  // å¤æ‚çš„åˆ—è¡¨è½¬æ¢é€»è¾‘
    } else 
        throw(RuntimeError("Unknown quoted typename"));
}
```

#### ç‚¹å¯¹è¯­æ³•éªŒè¯
- ç‚¹ç¬¦å·åªèƒ½å‡ºç°ä¸€æ¬¡
- ç‚¹ç¬¦å·å¿…é¡»åœ¨å€’æ•°ç¬¬äºŒä¸ªä½ç½®
- `(a . b . c)` æ˜¯éæ³•çš„
- `(a .)` æ˜¯éæ³•çš„

---

## ç®—æœ¯è¿ç®—è¡¨è¾¾å¼

### 6. Plus::evalRator() - äºŒå…ƒåŠ æ³•

#### è¯­æ³•å½¢å¼
```scheme
(+ 1 2)          ; æ•´æ•°åŠ æ³•
(+ 1/2 3)        ; æœ‰ç†æ•°ä¸æ•´æ•°
(+ 1/3 2/5)      ; æœ‰ç†æ•°åŠ æ³•
```

#### è¾¹ç•Œæƒ…å†µ
| æƒ…å†µ | è¾“å…¥ç±»å‹ | è¾“å‡º | é”™è¯¯å¤„ç† |
|------|----------|------|----------|
| **æ•´æ•°+æ•´æ•°** | `IntegerV`, `IntegerV` | `IntegerV` | å¯èƒ½æº¢å‡º |
| **æœ‰ç†æ•°+æ•´æ•°** | `RationalV`, `IntegerV` | `RationalV` | é€šåˆ†è®¡ç®— |
| **æ•´æ•°+æœ‰ç†æ•°** | `IntegerV`, `RationalV` | `RationalV` | é€šåˆ†è®¡ç®— |
| **æœ‰ç†æ•°+æœ‰ç†æ•°** | `RationalV`, `RationalV` | `RationalV` | å¤æ‚é€šåˆ† |
| **ç±»å‹é”™è¯¯** | å…¶ä»–ç±»å‹ç»„åˆ | - | `"Wrong typename"` |

#### å®ç°ä»£ç 
```cpp
Value Plus::evalRator(const Value &rand1, const Value &rand2) {
    if (rand1->v_type == V_INT and rand2->v_type == V_INT) {
        return IntegerV((dynamic_cast<Integer*>(rand1.get())->n) + 
                       (dynamic_cast<Integer*>(rand2.get())->n));
    } else if (rand1->v_type == V_RATIONAL and rand2->v_type == V_INT) {
        auto rat1 = dynamic_cast<Rational*>(rand1.get());
        int n2 = dynamic_cast<Integer*>(rand2.get())->n;
        return RationalV(rat1->numerator + n2 * rat1->denominator, rat1->denominator);
    } 
    // ... å…¶ä»–ç±»å‹ç»„åˆ
    throw(RuntimeError("Wrong typename"));
}
```

---

### 7. PlusVar::evalRator() - å¤šå‚æ•°åŠ æ³•

#### è¯­æ³•å½¢å¼
```scheme
(+)              ; é›¶å‚æ•°ï¼Œè¿”å›0
(+ 5)            ; å•å‚æ•°ï¼Œè¿”å›å‚æ•°æœ¬èº«  
(+ 1 2 3 4)      ; å¤šå‚æ•°æ±‚å’Œ
```

#### è¾¹ç•Œæƒ…å†µ
| æƒ…å†µ | å‚æ•°ä¸ªæ•° | è¾“å…¥ç¤ºä¾‹ | è¾“å‡º |
|------|----------|----------|------|
| **é›¶å‚æ•°** | 0 | `(+)` | `IntegerV(0)` |
| **å•å‚æ•°** | 1 | `(+ 5)` | `IntegerV(5)` |
| **ä¸¤å‚æ•°** | 2 | `(+ 1 2)` | `IntegerV(3)` |
| **å¤šå‚æ•°** | nâ‰¥3 | `(+ 1 2 3 4)` | `IntegerV(10)` |
| **æº¢å‡ºæƒ…å†µ** | - | æå¤§æ•°ç›¸åŠ  | å¯èƒ½æ•´æ•°æº¢å‡º |

#### å®ç°ä»£ç 
```cpp
Value PlusVar::evalRator(const std::vector<Value> &args) {
    if (args.empty()) {
        return IntegerV(0); // åŠ æ³•å•ä½å…ƒ
    }
    
    int result = 0;
    for (const auto& arg : args) {
        if (arg->v_type == V_INT) {
            result += dynamic_cast<Integer*>(arg.get())->n;
        } else {
            throw(RuntimeError("Wrong typename"));
        }
    }
    return IntegerV(result);
}
```

---

### 8. Minus / MinusVar - å‡æ³•è¿ç®—

#### è¯­æ³•å½¢å¼
```scheme
(- 5 3)          ; äºŒå…ƒå‡æ³•
(- 10)           ; å–è´Ÿæ•°
(- 10 3 2)       ; å¤šå‚æ•°å‡æ³• (10-3-2=5)
```

#### è¾¹ç•Œæƒ…å†µ
| æƒ…å†µ | å‚æ•°ä¸ªæ•° | è¾“å…¥ | è¾“å‡º | é”™è¯¯å¤„ç† |
|------|----------|------|------|----------|
| **é›¶å‚æ•°** | 0 | `(-)` | - | `"Wrong number of arguments for -"` |
| **å–è´Ÿ** | 1 | `(- 5)` | `IntegerV(-5)` | - |
| **äºŒå…ƒå‡æ³•** | 2 | `(- 8 3)` | `IntegerV(5)` | - |
| **å¤šå…ƒå‡æ³•** | nâ‰¥3 | `(- 10 3 2)` | `IntegerV(5)` | ä»å·¦åˆ°å³ä¾æ¬¡ç›¸å‡ |
| **ä¸‹æº¢** | - | `INT_MIN - 1` | å¯èƒ½æ•´æ•°ä¸‹æº¢ | - |

---

### 9. Div / DivVar - é™¤æ³•è¿ç®—

#### è¯­æ³•å½¢å¼
```scheme
(/ 6 2)          ; äºŒå…ƒé™¤æ³•ï¼Œè¿”å›æœ‰ç†æ•°
(/ 5)            ; å€’æ•°ï¼Œè¿”å› 1/5
(/ 12 3 2)       ; å¤šå‚æ•°é™¤æ³•
```

#### è¾¹ç•Œæƒ…å†µ
| æƒ…å†µ | è¾“å…¥ | è¾“å‡º | é”™è¯¯å¤„ç† |
|------|------|------|----------|
| **æ•´æ•°é™¤æ³•** | `(/ 6 3)` | `RationalV(2, 1)` | - |
| **äº§ç”Ÿåˆ†æ•°** | `(/ 1 3)` | `RationalV(1, 3)` | - |
| **æ±‚å€’æ•°** | `(/ 5)` | `RationalV(1, 5)` | - |
| **é™¤é›¶é”™è¯¯** | `(/ 5 0)` | - | `"Division by zero"` |
| **é›¶çš„å€’æ•°** | `(/ 0)` | - | `"Division by zero"` |
| **å¤šå‚æ•°** | `(/ 24 2 3)` | `RationalV(4, 1)` | - |

#### å®ç°ä»£ç 
```cpp
Value Div::evalRator(const Value &rand1, const Value &rand2) {
    if (rand1->v_type == V_INT and rand2->v_type == V_INT) {
        int dividend = dynamic_cast<Integer*>(rand1.get())->n;
        int divisor = dynamic_cast<Integer*>(rand2.get())->n;
        if (divisor == 0) {
            throw(RuntimeError("Division by zero"));
        }
        return RationalV(dividend, divisor);  // æ€»æ˜¯è¿”å›æœ‰ç†æ•°
    }
    throw(RuntimeError("Wrong typename"));
}
```

---

## æ¯”è¾ƒè¿ç®—è¡¨è¾¾å¼

### 10. Less / LessVar - å°äºæ¯”è¾ƒ

#### è¯­æ³•å½¢å¼
```scheme
(< 1 2)          ; äºŒå…ƒæ¯”è¾ƒ
(< 1 2 3 4)      ; å¤šå‚æ•°é“¾å¼æ¯”è¾ƒ
(< 5 3)          ; è¿”å›å‡çš„æ¯”è¾ƒ
```

#### è¾¹ç•Œæƒ…å†µ
| æƒ…å†µ | è¾“å…¥ | è¾“å‡º | è¯´æ˜ |
|------|------|------|------|
| **çœŸæ¯”è¾ƒ** | `(< 1 2)` | `BooleanV(true)` | 1 < 2 |
| **å‡æ¯”è¾ƒ** | `(< 3 2)` | `BooleanV(false)` | 3 ä¸< 2 |
| **ç›¸ç­‰** | `(< 2 2)` | `BooleanV(false)` | 2 ä¸< 2 |
| **é“¾å¼çœŸ** | `(< 1 2 3 4)` | `BooleanV(true)` | 1<2<3<4 |
| **é“¾å¼å‡** | `(< 1 3 2 4)` | `BooleanV(false)` | 3ä¸<2ï¼ŒçŸ­è·¯ |
| **å‚æ•°ä¸è¶³** | `(< 1)` | - | `"< requires at least 2 arguments"` |

#### å®ç°ä»£ç 
```cpp
Value LessVar::evalRator(const std::vector<Value> &args) {
    if (args.size() < 2) {
        throw(RuntimeError("< requires at least 2 arguments"));
    }
    
    for (size_t i = 0; i < args.size() - 1; i++) {
        if (args[i]->v_type != V_INT || args[i+1]->v_type != V_INT) {
            throw(RuntimeError("Wrong typename"));
        }
        int n1 = dynamic_cast<Integer*>(args[i].get())->n;
        int n2 = dynamic_cast<Integer*>(args[i+1].get())->n;
        if (!(n1 < n2)) {
            return BooleanV(false);  // çŸ­è·¯æ±‚å€¼
        }
    }
    return BooleanV(true);
}
```

---

### 11. Equal / EqualVar - ç›¸ç­‰æ¯”è¾ƒ

#### è¯­æ³•å½¢å¼
```scheme
(= 2 2)          ; äºŒå…ƒç›¸ç­‰
(= 1 1 1 1)      ; å¤šå‚æ•°ç›¸ç­‰
(= 2 3)          ; ä¸ç›¸ç­‰
```

#### è¾¹ç•Œæƒ…å†µ
| æƒ…å†µ | è¾“å…¥ | è¾“å‡º | æ”¯æŒç±»å‹ |
|------|------|------|----------|
| **æ•´æ•°ç›¸ç­‰** | `(= 5 5)` | `BooleanV(true)` | V_INT |
| **æ•´æ•°ä¸ç­‰** | `(= 5 3)` | `BooleanV(false)` | V_INT |
| **å¤šå‚æ•°å…¨ç­‰** | `(= 2 2 2)` | `BooleanV(true)` | é“¾å¼æ£€æŸ¥ |
| **å¤šå‚æ•°ä¸ç­‰** | `(= 2 2 3)` | `BooleanV(false)` | çŸ­è·¯è¿”å› |
| **æœ‰ç†æ•°æ¯”è¾ƒ** | `(= 1/2 2/4)` | `BooleanV(true)` | åŒ–ç®€åæ¯”è¾ƒ |

---

## é€»è¾‘è¿ç®—è¡¨è¾¾å¼

### 12. And::eval() - é€»è¾‘ä¸

#### è¯­æ³•å½¢å¼
```scheme
(and)            ; ç©ºandï¼Œè¿”å›#t
(and #t #t #t)   ; å…¨çœŸï¼Œè¿”å›æœ€åå€¼
(and #t #f #t)   ; åŒ…å«å‡å€¼ï¼ŒçŸ­è·¯è¿”å›#f
(and 1 2 3)      ; éå¸ƒå°”å€¼ï¼Œè¿”å›æœ€åå€¼
```

#### è¾¹ç•Œæƒ…å†µ
| æƒ…å†µ | è¾“å…¥ | è¾“å‡º | è¡Œä¸ºè¯´æ˜ |
|------|------|------|----------|
| **ç©ºå‚æ•°** | `(and)` | `BooleanV(true)` | é€»è¾‘ä¸å•ä½å…ƒ |
| **å•å‚æ•°çœŸ** | `(and #t)` | `BooleanV(true)` | è¿”å›å‚æ•°å€¼ |
| **å•å‚æ•°å‡** | `(and #f)` | `BooleanV(false)` | è¿”å›å‚æ•°å€¼ |
| **å…¨çœŸå€¼** | `(and 1 2 3)` | `IntegerV(3)` | è¿”å›æœ€åå€¼ |
| **åŒ…å«å‡** | `(and 1 #f 3)` | `BooleanV(false)` | çŸ­è·¯æ±‚å€¼ |
| **æ··åˆç±»å‹** | `(and "hello" 42)` | `IntegerV(42)` | é#féƒ½æ˜¯çœŸ |

#### å®ç°ä»£ç 
```cpp
Value And::eval(Assoc &e) {
    if (es.size() == 0) return BooleanV(true);
    
    for (int i = 0; i < es.size(); i++) {
        Value val = es[i]->eval(e);
        // åœ¨ Scheme ä¸­ï¼Œåªæœ‰ #f æ˜¯å‡å€¼
        if (val->v_type == V_BOOL) {
            Boolean* b = dynamic_cast<Boolean*>(val.get());
            if (!b->b) {  // å¦‚æœæ˜¯ #f
                return BooleanV(false);  // çŸ­è·¯æ±‚å€¼
            }
        }
        // å¦‚æœæ˜¯æœ€åä¸€ä¸ªå‚æ•°ï¼Œè¿”å›å®ƒçš„å€¼
        if (i == es.size() - 1) {
            return val;
        }
    }
    return BooleanV(true);
}
```

---

### 13. Or::eval() - é€»è¾‘æˆ–

#### è¯­æ³•å½¢å¼
```scheme
(or)             ; ç©ºorï¼Œè¿”å›#f
(or #f #f #t)    ; åŒ…å«çœŸå€¼ï¼Œè¿”å›é¦–ä¸ªçœŸå€¼
(or #f #f #f)    ; å…¨å‡ï¼Œè¿”å›#f
(or 1 2 3)       ; è¿”å›é¦–ä¸ªé#få€¼
```

#### è¾¹ç•Œæƒ…å†µ
| æƒ…å†µ | è¾“å…¥ | è¾“å‡º | è¡Œä¸ºè¯´æ˜ |
|------|------|------|----------|
| **ç©ºå‚æ•°** | `(or)` | `BooleanV(false)` | é€»è¾‘æˆ–é›¶å…ƒ |
| **å…¨å‡å€¼** | `(or #f #f)` | `BooleanV(false)` | æœ€åè¿”å›#f |
| **é¦–ä¸ªçœŸ** | `(or #t #f)` | `BooleanV(true)` | çŸ­è·¯è¿”å›é¦–ä¸ªçœŸå€¼ |
| **éå¸ƒå°”çœŸ** | `(or #f 42)` | `IntegerV(42)` | è¿”å›é¦–ä¸ªé#få€¼ |
| **æ··åˆç±»å‹** | `(or #f "hello")` | `StringV("hello")` | å­—ç¬¦ä¸²æ˜¯çœŸå€¼ |

---

### 14. Not::evalRator() - é€»è¾‘é

#### è¯­æ³•å½¢å¼
```scheme
(not #t)         ; å¯¹çœŸå€¼å–é
(not #f)         ; å¯¹å‡å€¼å–é
(not 42)         ; å¯¹éå¸ƒå°”å€¼å–é
```

#### è¾¹ç•Œæƒ…å†µ
| æƒ…å†µ | è¾“å…¥ | è¾“å‡º | è¯´æ˜ |
|------|------|------|------|
| **éçœŸå€¼** | `(not #t)` | `BooleanV(false)` | #tå˜#f |
| **éå‡å€¼** | `(not #f)` | `BooleanV(true)` | åªæœ‰#få˜#t |
| **éæ•°å­—** | `(not 0)` | `BooleanV(false)` | 0ä¸æ˜¯å‡å€¼ |
| **éå­—ç¬¦ä¸²** | `(not "")` | `BooleanV(false)` | ç©ºä¸²ä¸æ˜¯å‡å€¼ |
| **éç©ºåˆ—è¡¨** | `(not '())` | `BooleanV(false)` | ç©ºåˆ—è¡¨ä¸æ˜¯å‡å€¼ |

#### å®ç°ä»£ç 
```cpp
Value Not::evalRator(const Value &rand) {
    if (rand->v_type == V_BOOL and (dynamic_cast<Boolean*>(rand.get())->b == false))
        return BooleanV(true);
    else
        return BooleanV(false);
}
```

---

## æ§åˆ¶æµè¡¨è¾¾å¼

### 15. If::eval() - æ¡ä»¶è¡¨è¾¾å¼

#### è¯­æ³•å½¢å¼
```scheme
(if #t 1 2)      ; æ ‡å‡†æ¡ä»¶
(if #f 1 2)      ; å‡æ¡ä»¶
(if 0 1 2)       ; éå¸ƒå°”æ¡ä»¶
(if '() 1 2)     ; ç©ºåˆ—è¡¨æ¡ä»¶
```

#### è¾¹ç•Œæƒ…å†µ
| æƒ…å†µ | æ¡ä»¶ | è¾“å‡º | è¯´æ˜ |
|------|------|------|------|
| **çœŸæ¡ä»¶** | `#t` | æ‰§è¡Œthenåˆ†æ”¯ | å”¯ä¸€çš„çœŸå¸ƒå°”å€¼ |
| **å‡æ¡ä»¶** | `#f` | æ‰§è¡Œelseåˆ†æ”¯ | å”¯ä¸€çš„å‡å€¼ |
| **æ•°å­—æ¡ä»¶** | `0`, `42`, `-1` | æ‰§è¡Œthenåˆ†æ”¯ | æ‰€æœ‰æ•°å­—éƒ½æ˜¯çœŸå€¼ |
| **å­—ç¬¦ä¸²æ¡ä»¶** | `""`, `"hello"` | æ‰§è¡Œthenåˆ†æ”¯ | æ‰€æœ‰å­—ç¬¦ä¸²éƒ½æ˜¯çœŸå€¼ |
| **åˆ—è¡¨æ¡ä»¶** | `'()`, `'(1 2)` | æ‰§è¡Œthenåˆ†æ”¯ | æ‰€æœ‰åˆ—è¡¨éƒ½æ˜¯çœŸå€¼ |
| **ç¬¦å·æ¡ä»¶** | `'symbol` | æ‰§è¡Œthenåˆ†æ”¯ | æ‰€æœ‰ç¬¦å·éƒ½æ˜¯çœŸå€¼ |

#### å®ç°ä»£ç 
```cpp
Value If::eval(Assoc &e) {
    Value valueof_condition = cond->eval(e);
    // åªæœ‰å½“æ¡ä»¶æ˜¯ Boolean ç±»å‹ä¸”å€¼ä¸º false æ—¶ï¼Œæ‰è¿”å› alter åˆ†æ”¯
    if (valueof_condition->v_type == V_BOOL && 
        dynamic_cast<Boolean*>(valueof_condition.get())->b == false) {
        return alter->eval(e);
    } else {
        return conseq->eval(e);
    }
}
```

---

### 16. Cond::eval() - å¤šè·¯æ¡ä»¶

#### è¯­æ³•å½¢å¼
```scheme
(cond 
  ((< x 0) "negative")
  ((= x 0) "zero") 
  ((> x 0) "positive"))

(cond 
  (#f "never")
  (else "default"))
```

#### è¾¹ç•Œæƒ…å†µ
| æƒ…å†µ | è¾“å…¥ | è¾“å‡º | è¯´æ˜ |
|------|------|------|------|
| **é¦–åˆ†æ”¯åŒ¹é…** | ç¬¬ä¸€ä¸ªæ¡ä»¶ä¸ºçœŸ | æ‰§è¡Œé¦–åˆ†æ”¯ä½“ | çŸ­è·¯æ±‚å€¼ |
| **ä¸­é—´åˆ†æ”¯åŒ¹é…** | ä¸­é—´æ¡ä»¶ä¸ºçœŸ | æ‰§è¡Œå¯¹åº”åˆ†æ”¯ | è·³è¿‡å‰é¢åˆ†æ”¯ |
| **elseåˆ†æ”¯** | å‰é¢éƒ½ä¸ºå‡ | æ‰§è¡Œelseåˆ†æ”¯ | é»˜è®¤åˆ†æ”¯ |
| **æ— åŒ¹é…åˆ†æ”¯** | æ‰€æœ‰æ¡ä»¶éƒ½ä¸ºå‡ | `VoidV()` | è¿”å›void |
| **ç©ºelseåˆ†æ”¯** | `(else)` | `VoidV()` | elseæ— è¡¨è¾¾å¼ |
| **å•æ¡ä»¶åˆ†æ”¯** | `(cond (#t))` | è¿”å›æ¡ä»¶å€¼`#t` | æ— è¡¨è¾¾å¼ä½“ |

#### å¤æ‚ç¤ºä¾‹
```scheme
;; å¤šè¡¨è¾¾å¼åˆ†æ”¯
(cond 
  ((> x 0) 
   (display "positive")
   (display "!")
   x))  ; è¿”å›xçš„å€¼

;; åµŒå¥—cond
(cond 
  ((number? x) 
   (cond 
     ((> x 0) "positive number")
     (else "non-positive number")))
  (else "not a number"))
```

---

### 17. Begin::eval() - é¡ºåºæ‰§è¡Œ

#### è¯­æ³•å½¢å¼
```scheme
(begin)                    ; ç©ºbegin
(begin 1 2 3)             ; å¤šè¡¨è¾¾å¼
(begin 
  (define x 1)
  (define y 2)
  (+ x y))                ; åŒ…å«å†…éƒ¨å®šä¹‰
```

#### è¾¹ç•Œæƒ…å†µ
| æƒ…å†µ | è¾“å…¥ | è¾“å‡º | å¤„ç†æ–¹å¼ |
|------|------|------|----------|
| **ç©ºbegin** | `(begin)` | `VoidV()` | æ— è¡¨è¾¾å¼æ‰§è¡Œ |
| **å•è¡¨è¾¾å¼** | `(begin 42)` | `IntegerV(42)` | è¿”å›å”¯ä¸€è¡¨è¾¾å¼å€¼ |
| **å¤šè¡¨è¾¾å¼** | `(begin 1 2 3)` | `IntegerV(3)` | è¿”å›æœ€åè¡¨è¾¾å¼å€¼ |
| **çº¯å†…éƒ¨å®šä¹‰** | åªå«define | `VoidV()` | ç±»ä¼¼letrecè¯­ä¹‰ |
| **æ··åˆå®šä¹‰** | define+è¡¨è¾¾å¼ | æœ€åè¡¨è¾¾å¼å€¼ | å®šä¹‰åœ¨å‰ï¼Œè¡¨è¾¾å¼åœ¨å |

#### å†…éƒ¨å®šä¹‰å¤„ç†
```cpp
// æŸ¥æ‰¾è¿ç»­çš„å†…éƒ¨å®šä¹‰
std::vector<std::pair<std::string, Expr>> internal_defs;
int first_non_define = 0;

for (int i = 0; i < es.size(); i++) {
    if (es[i]->e_type == E_DEFINE) {
        Define* def = dynamic_cast<Define*>(es[i].get());
        if (def) {
            internal_defs.push_back({def->var, def->e});
            first_non_define = i + 1;
        } else {
            break;
        }
    } else {
        break;
    }
}
```

---

## ç»‘å®šå’Œå®šä¹‰è¡¨è¾¾å¼

### 18. Let::eval() - å±€éƒ¨ç»‘å®š

#### è¯­æ³•å½¢å¼
```scheme
(let () 42)                        ; ç©ºç»‘å®š
(let ((x 1)) x)                    ; å•ç»‘å®š
(let ((x 1) (y 2)) (+ x y))       ; å¤šç»‘å®š
(let ((x 1) (x 2)) x)             ; å˜é‡å±è”½
```

#### è¾¹ç•Œæƒ…å†µ
| æƒ…å†µ | è¾“å…¥ | è¾“å‡º | è¯´æ˜ |
|------|------|------|------|
| **ç©ºç»‘å®š** | `(let () 42)` | `IntegerV(42)` | æ— å±€éƒ¨å˜é‡ |
| **å•ç»‘å®š** | `(let ((x 5)) x)` | `IntegerV(5)` | åŸºæœ¬ç»‘å®š |
| **å˜é‡å±è”½** | `(let ((x 1) (x 2)) x)` | `IntegerV(2)` | åç»‘å®šè¦†ç›–å‰ç»‘å®š |
| **å¤–å±‚å˜é‡** | å¼•ç”¨å¤–å±‚åŒåå˜é‡ | å¤–å±‚å€¼ | letç»‘å®šä¸ç›¸äº’ä¾èµ– |
| **è¡¨è¾¾å¼ç»‘å®š** | `(let ((x (+ 1 2))) x)` | `IntegerV(3)` | ç»‘å®šè®¡ç®—ç»“æœ |

#### æ±‚å€¼é¡ºåº
```cpp
Value Let::eval(Assoc &env) {
    // ç¬¬ä¸€é˜¶æ®µï¼šåœ¨åŸç¯å¢ƒä¸­æ±‚å€¼æ‰€æœ‰ç»‘å®šè¡¨è¾¾å¼
    std::vector<std::pair<std::string, Value>> tobind;
    for (auto binded_pair : bind) {
        tobind.push_back({binded_pair.first, binded_pair.second->eval(env)});
    }
    
    // ç¬¬äºŒé˜¶æ®µï¼šæ‰©å±•ç¯å¢ƒ
    Assoc cur_env = env;
    for (auto binded_pair : tobind) {
        cur_env = extend(binded_pair.first, binded_pair.second, cur_env);
    }
    
    // ç¬¬ä¸‰é˜¶æ®µï¼šåœ¨æ–°ç¯å¢ƒä¸­æ±‚å€¼body
    return body->eval(cur_env);
}
```

---

### 19. Letrec::eval() - é€’å½’ç»‘å®š

#### è¯­æ³•å½¢å¼
```scheme
(letrec ((fact (lambda (n) 
                 (if (<= n 1) 1 
                     (* n (fact (- n 1)))))))
  (fact 5))

(letrec ((even? (lambda (n) (if (= n 0) #t (odd? (- n 1)))))
         (odd?  (lambda (n) (if (= n 0) #f (even? (- n 1))))))
  (even? 10))
```

#### è¾¹ç•Œæƒ…å†µ
| æƒ…å†µ | è¾“å…¥ | è¾“å‡º | è¯´æ˜ |
|------|------|------|------|
| **ç®€å•é€’å½’** | é˜¶ä¹˜å‡½æ•° | è®¡ç®—ç»“æœ | è‡ªå¼•ç”¨å‡½æ•° |
| **ç›¸äº’é€’å½’** | even?/odd? | è®¡ç®—ç»“æœ | å‡½æ•°é—´ç›¸äº’è°ƒç”¨ |
| **éé€’å½’ä½¿ç”¨** | æ™®é€šå˜é‡ç»‘å®š | æ­£å¸¸å·¥ä½œ | å…¼å®¹letè¯­ä¹‰ |
| **å‰å‘å¼•ç”¨** | åå®šä¹‰çš„å‡½æ•° | æ­£ç¡®è§£æ | ç¯å¢ƒé¢„æ„å»º |

#### å®ç°ç­–ç•¥
```cpp
Value Letrec::eval(Assoc &env) {
    // 1. åˆ›å»ºæ–°ä½œç”¨åŸŸ env1
    Assoc env1 = env;

    // 2. å°†æ‰€æœ‰å˜é‡ä¸ nullptr ç»‘å®š
    for (const auto &binding : bind) {
        env1 = extend(binding.first, Value(nullptr), env1);
    }

    // 3. åœ¨ env1 ä¸‹æ±‚å€¼æ‰€æœ‰è¡¨è¾¾å¼
    std::vector<std::pair<std::string,Value>> bindings;
    for (const auto &binding : bind) {
        bindings.push_back(std::make_pair(binding.first, binding.second->eval(env1)));
    }

    // 4. æ›´æ–°ç»‘å®šä¸ºå®é™…å€¼
    Assoc env2 = env1;
    for (const auto &binding: bindings) {
        modify(binding.first, binding.second, env2);
    }

    // 5. åœ¨æœ€ç»ˆç¯å¢ƒä¸­æ±‚å€¼body
    return body->eval(env2);
}
```

---

### 20. Define::eval() - å˜é‡/å‡½æ•°å®šä¹‰

#### è¯­æ³•å½¢å¼
```scheme
(define x 42)                    ; å˜é‡å®šä¹‰
(define (square x) (* x x))      ; å‡½æ•°å®šä¹‰è¯­æ³•ç³–
(define (fact n)                 ; é€’å½’å‡½æ•°
  (if (<= n 1) 1 (* n (fact (- n 1)))))
```

#### è¾¹ç•Œæƒ…å†µ
| æƒ…å†µ | è¾“å…¥ | è¾“å‡º | é”™è¯¯å¤„ç† |
|------|------|------|----------|
| **ç®€å•å˜é‡** | `(define x 5)` | `VoidV()` | åˆ›å»ºç»‘å®š |
| **å‡½æ•°å®šä¹‰** | `(define (f x) x)` | `VoidV()` | åˆ›å»ºlambda |
| **é‡æ–°å®šä¹‰** | é‡å®šä¹‰å·²å­˜åœ¨å˜é‡ | `VoidV()` | æ›´æ–°ç»‘å®š |
| **é€’å½’å‡½æ•°** | è‡ªå¼•ç”¨å‡½æ•° | `VoidV()` | å ä½ç¬¦æœºåˆ¶ |
| **é‡å®šä¹‰åŸè¯­** | `(define + -)` | - | `"Cannot redefine primitive"` |

#### é€’å½’æ”¯æŒæœºåˆ¶
```cpp
Value Define::eval(Assoc &env) {
    // æ£€æŸ¥æ˜¯å¦é‡æ–°å®šä¹‰åŸè¯­
    if (primitives.count(var) || reserved_words.count(var)) {
        throw RuntimeError("Cannot redefine primitive: " + var);
    }
    
    // å…ˆåˆ›å»ºå ä½ç¬¦ç»‘å®šæ”¯æŒé€’å½’
    env = extend(var, Value(nullptr), env);
    
    // åœ¨åŒ…å«å ä½ç¬¦çš„ç¯å¢ƒä¸­æ±‚å€¼è¡¨è¾¾å¼
    Value val = e->eval(env);
    
    // æ›´æ–°ä¸ºå®é™…å€¼
    modify(var, val, env);
    
    return VoidV();
}
```

---

### 21. Set::eval() - å˜é‡èµ‹å€¼

#### è¯­æ³•å½¢å¼
```scheme
(set! x 20)                    ; ä¿®æ”¹å·²å­˜åœ¨å˜é‡
(set! undefined-var 10)        ; é”™è¯¯ï¼šå˜é‡æœªå®šä¹‰
```

#### è¾¹ç•Œæƒ…å†µ
| æƒ…å†µ | è¾“å…¥ | è¾“å‡º | é”™è¯¯å¤„ç† |
|------|------|------|----------|
| **æ­£å¸¸èµ‹å€¼** | å·²å­˜åœ¨å˜é‡ | `VoidV()` | ä¿®æ”¹ç»‘å®š |
| **æœªå®šä¹‰å˜é‡** | ä¸å­˜åœ¨çš„å˜é‡ | - | `"Undefined variable in set!"` |
| **ä¿®æ”¹é—­åŒ…å˜é‡** | é—­åŒ…æ•è·çš„å˜é‡ | `VoidV()` | ä¿®æ”¹å¤–å±‚ç»‘å®š |

---

## å‡½æ•°ç›¸å…³è¡¨è¾¾å¼

### 22. Lambda::eval() - å‡½æ•°åˆ›å»º

#### è¯­æ³•å½¢å¼
```scheme
(lambda () 42)                 ; æ— å‚å‡½æ•°
(lambda (x) x)                 ; å•å‚å‡½æ•°
(lambda (x y z) (+ x y z))     ; å¤šå‚å‡½æ•°
```

#### è¾¹ç•Œæƒ…å†µ
| æƒ…å†µ | è¾“å…¥ | è¾“å‡º | è¯´æ˜ |
|------|------|------|------|
| **æ— å‚lambda** | `(lambda () 42)` | `ProcedureV([], body, env)` | ç©ºå‚æ•°åˆ—è¡¨ |
| **å•å‚lambda** | `(lambda (x) x)` | `ProcedureV(["x"], body, env)` | æ ‡å‡†æƒ…å†µ |
| **å¤šå‚lambda** | `(lambda (x y) (+ x y))` | `ProcedureV(["x","y"], body, env)` | å¤šä¸ªå‚æ•° |
| **é—­åŒ…æ•è·** | å¼•ç”¨å¤–å±‚å˜é‡çš„lambda | æ•è·å¤–å±‚ç¯å¢ƒ | è¯æ³•ä½œç”¨åŸŸ |

#### å®ç°ä»£ç 
```cpp
Value Lambda::eval(Assoc &env) {
    Assoc new_env = env;  // æ•è·å½“å‰ç¯å¢ƒ
    return ProcedureV(x, e, new_env);  // åˆ›å»ºé—­åŒ…
}
```

---

### 23. Apply::eval() - å‡½æ•°è°ƒç”¨

#### è¯­æ³•å½¢å¼
```scheme
(func arg1 arg2)               ; åŸºæœ¬å‡½æ•°è°ƒç”¨
((lambda (x) x) 42)           ; lambdaç›´æ¥è°ƒç”¨
(+ 1 2 3)                     ; åŸè¯­å‡½æ•°è°ƒç”¨
```

#### è¾¹ç•Œæƒ…å†µ
| æƒ…å†µ | è¾“å…¥ | è¾“å‡º | é”™è¯¯å¤„ç† |
|------|------|------|----------|
| **æ­£å¸¸è°ƒç”¨** | å‚æ•°åŒ¹é…çš„è°ƒç”¨ | å‡½æ•°æ‰§è¡Œç»“æœ | - |
| **å‚æ•°ä¸åŒ¹é…** | å‚æ•°ä¸ªæ•°é”™è¯¯ | - | `"Wrong number of arguments"` |
| **éå‡½æ•°è°ƒç”¨** | å¯¹éprocedureè°ƒç”¨ | - | `"Attempt to apply a non-procedure"` |
| **åŸè¯­è°ƒç”¨** | è°ƒç”¨+ã€-ç­‰åŸè¯­ | è®¡ç®—ç»“æœ | åŠ¨æ€åŒ…è£… |
| **é€’å½’è°ƒç”¨** | å‡½æ•°è‡ªè°ƒç”¨ | é€’å½’ç»“æœæˆ–æ ˆæº¢å‡º | - |

#### äº”é˜¶æ®µæ‰§è¡Œè¿‡ç¨‹
```cpp
Value Apply::eval(Assoc &e) {
    // é˜¶æ®µ1ï¼šæ±‚å€¼å‡½æ•°è¡¨è¾¾å¼
    Value mid_fun = rator->eval(e);
    if (mid_fun->v_type != V_PROC) {
        throw RuntimeError("Attempt to apply a non-procedure");
    }

    Procedure* clos_ptr = dynamic_cast<Procedure*>(mid_fun.get());
    
    // é˜¶æ®µ2ï¼šæ±‚å€¼å‚æ•°è¡¨è¾¾å¼
    std::vector<Value> args;
    for (int i = 0; i < rand.size(); i++) {
        args.push_back(rand[i]->eval(e));
    }

    // é˜¶æ®µ3ï¼šå‚æ•°æ•°é‡éªŒè¯
    if (args.size() != clos_ptr->parameters.size()) {
        throw RuntimeError("Wrong number of arguments");
    }

    // é˜¶æ®µ4ï¼šæ„å»ºæ‰§è¡Œç¯å¢ƒ
    Assoc param_env = clos_ptr->env;
    for (int i = 0; i < clos_ptr->parameters.size(); i++) {
        param_env = extend(clos_ptr->parameters[i], args[i], param_env);
    }

    // é˜¶æ®µ5ï¼šæ‰§è¡Œå‡½æ•°ä½“
    return clos_ptr->e->eval(param_env);
}
```

---

## åˆ—è¡¨æ“ä½œè¡¨è¾¾å¼

### 24. Cons::evalRator() - æ„é€ å¯¹å¶

#### è¯­æ³•å½¢å¼
```scheme
(cons 1 2)                     ; åŸºæœ¬å¯¹å¶
(cons 1 '())                   ; åˆ—è¡¨å…ƒç´ 
(cons '(1 2) '(3 4))          ; åµŒå¥—åˆ—è¡¨
```

#### è¾¹ç•Œæƒ…å†µ
| æƒ…å†µ | è¾“å…¥ | è¾“å‡º | è¯´æ˜ |
|------|------|------|------|
| **åŸºæœ¬å¯¹å¶** | `(cons 1 2)` | `PairV(IntegerV(1), IntegerV(2))` | ç‚¹å¯¹ |
| **åˆ—è¡¨æ„é€ ** | `(cons 1 '())` | `PairV(IntegerV(1), NullV())` | å•å…ƒç´ åˆ—è¡¨ |
| **åµŒå¥—ç»“æ„** | `(cons '(1) '(2))` | åµŒå¥—çš„å¯¹å¶ç»“æ„ | å¤æ‚åˆ—è¡¨ |
| **æ··åˆç±»å‹** | `(cons #t "hello")` | `PairV(BooleanV(true), StringV("hello"))` | ä¸åŒç±»å‹ |

---

### 25. Car::evalRator() / Cdr::evalRator() - åˆ—è¡¨è®¿é—®

#### è¯­æ³•å½¢å¼
```scheme
(car (cons 1 2))               ; è·å–ç¬¬ä¸€ä¸ªå…ƒç´ 
(cdr (cons 1 2))               ; è·å–ç¬¬äºŒä¸ªå…ƒç´ 
(car '(1 2 3))                 ; åˆ—è¡¨ç¬¬ä¸€ä¸ªå…ƒç´ 
(cdr '(1 2 3))                 ; åˆ—è¡¨å‰©ä½™éƒ¨åˆ†
```

#### è¾¹ç•Œæƒ…å†µ
| æƒ…å†µ | è¾“å…¥ | è¾“å‡º | é”™è¯¯å¤„ç† |
|------|------|------|----------|
| **å¯¹å¶car** | `(car (cons 1 2))` | `IntegerV(1)` | - |
| **å¯¹å¶cdr** | `(cdr (cons 1 2))` | `IntegerV(2)` | - |
| **åˆ—è¡¨car** | `(car '(1 2 3))` | `IntegerV(1)` | - |
| **åˆ—è¡¨cdr** | `(cdr '(1 2 3))` | `PairV(2, PairV(3, NullV()))` | - |
| **éå¯¹å¶é”™è¯¯** | `(car 42)` | - | `"Wrong typename"` |
| **ç©ºåˆ—è¡¨é”™è¯¯** | `(car '())` | - | `"Wrong typename"` |

---

### 26. SetCar::evalRator() / SetCdr::evalRator() - ç ´åæ€§ä¿®æ”¹

#### è¯­æ³•å½¢å¼
```scheme
(define p (cons 1 2))
(set-car! p 10)                ; ä¿®æ”¹ç¬¬ä¸€ä¸ªå…ƒç´ 
(set-cdr! p 20)                ; ä¿®æ”¹ç¬¬äºŒä¸ªå…ƒç´ 
```

#### è¾¹ç•Œæƒ…å†µ
| æƒ…å†µ | è¾“å…¥ | è¾“å‡º | é”™è¯¯å¤„ç† |
|------|------|------|----------|
| **ä¿®æ”¹car** | `(set-car! pair new-val)` | `VoidV()` | ç ´åæ€§ä¿®æ”¹ |
| **ä¿®æ”¹cdr** | `(set-cdr! pair new-val)` | `VoidV()` | ç ´åæ€§ä¿®æ”¹ |
| **éå¯¹å¶é”™è¯¯** | `(set-car! 42 1)` | - | `"argument must be a pair"` |
| **ä¿®æ”¹å…±äº«** | ä¿®æ”¹è¢«å¤šå¤„å¼•ç”¨çš„å¯¹å¶ | å½±å“æ‰€æœ‰å¼•ç”¨ | å‰¯ä½œç”¨ |

---

### 27. ListFunc::evalRator() - åˆ—è¡¨æ„é€ 

#### è¯­æ³•å½¢å¼
```scheme
(list)                         ; ç©ºåˆ—è¡¨
(list 1)                       ; å•å…ƒç´ åˆ—è¡¨
(list 1 2 3)                   ; å¤šå…ƒç´ åˆ—è¡¨
(list 'a "b" 3)                ; æ··åˆç±»å‹åˆ—è¡¨
```

#### è¾¹ç•Œæƒ…å†µ
| æƒ…å†µ | è¾“å…¥ | è¾“å‡º | è¯´æ˜ |
|------|------|------|------|
| **ç©ºåˆ—è¡¨** | `(list)` | `NullV()` | æ— å‚æ•° |
| **å•å…ƒç´ ** | `(list 42)` | `PairV(IntegerV(42), NullV())` | åŸºæœ¬åˆ—è¡¨ |
| **å¤šå…ƒç´ ** | `(list 1 2 3)` | é€’å½’æ„å»ºçš„å¯¹å¶é“¾ | æ­£å¸¸åˆ—è¡¨ |
| **æ··åˆç±»å‹** | `(list #t "hi" 5)` | åŒ…å«ä¸åŒç±»å‹çš„åˆ—è¡¨ | ç±»å‹çµæ´» |

#### å®ç°ä»£ç 
```cpp
Value ListFunc::evalRator(const std::vector<Value> &args) {
    if (args.empty()) {
        return NullV(); // ç©ºåˆ—è¡¨
    }
    
    // ä»å³å‘å·¦æ„å»ºåˆ—è¡¨
    Value result = NullV();
    for (int i = args.size() - 1; i >= 0; i--) {
        result = PairV(args[i], result);
    }
    
    return result;
}
```

---

## ç±»å‹è°“è¯è¡¨è¾¾å¼

### 28. å„ç§ç±»å‹æ£€æŸ¥è°“è¯

#### è¯­æ³•å½¢å¼å’Œè¾¹ç•Œæƒ…å†µ

| è°“è¯ | è¯­æ³• | è¿”å›#tçš„æƒ…å†µ | è¿”å›#fçš„æƒ…å†µ |
|------|------|-------------|-------------|
| **number?** | `(number? x)` | æ•´æ•°ã€æœ‰ç†æ•° | å…¶ä»–æ‰€æœ‰ç±»å‹ |
| **boolean?** | `(boolean? x)` | `#t`, `#f` | å…¶ä»–æ‰€æœ‰ç±»å‹ |
| **string?** | `(string? x)` | `"hello"`, `""` | å…¶ä»–æ‰€æœ‰ç±»å‹ |
| **symbol?** | `(symbol? x)` | `'hello`, `'x` | å…¶ä»–æ‰€æœ‰ç±»å‹ |
| **null?** | `(null? x)` | `'()`, `(list)` | å…¶ä»–æ‰€æœ‰ç±»å‹ |
| **pair?** | `(pair? x)` | `(cons 1 2)`, `'(1 2)` | åŸå­å€¼ã€`'()` |
| **procedure?** | `(procedure? x)` | lambdaã€åŸè¯­å‡½æ•° | å…¶ä»–æ‰€æœ‰ç±»å‹ |

#### List? çš„å¤æ‚åˆ¤æ–­
```scheme
(list? '())                    ; #t - ç©ºåˆ—è¡¨
(list? '(1 2 3))              ; #t - æ­£å¸¸åˆ—è¡¨  
(list? (cons 1 2))            ; #f - ä¸è§„èŒƒåˆ—è¡¨
(list? (cons 1 (cons 2 '()))) ; #t - ä»¥nullç»“å°¾
```

#### List? å®ç°ç»†èŠ‚
```cpp
Value IsList::evalRator(const Value &rand) {
    if (rand->v_type == V_NULL) {
        return BooleanV(true); // ç©ºåˆ—è¡¨æ˜¯åˆ—è¡¨
    }
    
    if (rand->v_type != V_PAIR) {
        return BooleanV(false); // ä¸æ˜¯pairå°±ä¸æ˜¯åˆ—è¡¨
    }
    
    // ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆæ£€æµ‹ç¯å½¢åˆ—è¡¨
    Value slow = rand;
    Value fast = rand;
    
    while (true) {
        // å¿«æŒ‡é’ˆå‰è¿›ä¸¤æ­¥
        if (fast->v_type != V_PAIR) break;
        fast = dynamic_cast<Pair*>(fast.get())->cdr;
        if (fast->v_type != V_PAIR) break;
        fast = dynamic_cast<Pair*>(fast.get())->cdr;
        
        // æ…¢æŒ‡é’ˆå‰è¿›ä¸€æ­¥
        slow = dynamic_cast<Pair*>(slow.get())->cdr;
        
        // æ£€æµ‹ç¯å½¢
        if (slow.get() == fast.get()) {
            return BooleanV(false); // ç¯å½¢åˆ—è¡¨ä¸æ˜¯æ­£å¸¸åˆ—è¡¨
        }
    }
    
    // æ£€æŸ¥æœ€åæ˜¯å¦ä»¥nullç»“å°¾
    return BooleanV(fast->v_type == V_NULL);
}
```

---

## ç³»ç»Ÿæ§åˆ¶è¡¨è¾¾å¼

### 29. MakeVoid::eval() - æ˜¾å¼Void

#### è¯­æ³•å½¢å¼
```scheme
(void)                         ; æ˜¾å¼åˆ›å»ºvoidå€¼
```

#### è¾¹ç•Œæƒ…å†µ
| æƒ…å†µ | è¾“å…¥ | è¾“å‡º | è¯´æ˜ |
|------|------|------|------|
| **æ˜¾å¼void** | `(void)` | `VoidV()` | æ˜ç¡®è¿”å›void |

---

### 30. Exit::eval() - ç¨‹åºé€€å‡º

#### è¯­æ³•å½¢å¼
```scheme
(exit)                         ; é€€å‡ºç¨‹åº
```

#### è¾¹ç•Œæƒ…å†µ
| æƒ…å†µ | è¾“å…¥ | è¾“å‡º | è¯´æ˜ |
|------|------|------|------|
| **æ­£å¸¸é€€å‡º** | `(exit)` | `TerminateV()` | ç¨‹åºç»ˆæ­¢ä¿¡å· |

---

### 31. Display::evalRator() - è¾“å‡ºå‡½æ•°

#### è¯­æ³•å½¢å¼
```scheme
(display "hello")              ; è¾“å‡ºå­—ç¬¦ä¸²
(display 42)                   ; è¾“å‡ºæ•°å­—
(display #t)                   ; è¾“å‡ºå¸ƒå°”å€¼
(display '(1 2 3))            ; è¾“å‡ºåˆ—è¡¨
```

#### è¾¹ç•Œæƒ…å†µ
| æƒ…å†µ | è¾“å…¥ç±»å‹ | è¾“å‡ºåˆ°å±å¹• | è¿”å›å€¼ |
|------|----------|------------|--------|
| **å­—ç¬¦ä¸²** | `StringV` | ä¸å¸¦å¼•å·çš„å†…å®¹ | `VoidV()` |
| **æ•´æ•°** | `IntegerV` | æ•°å­—å½¢å¼ | `VoidV()` |
| **å¸ƒå°”** | `BooleanV` | `#t` æˆ– `#f` | `VoidV()` |
| **åˆ—è¡¨** | `PairV` | `(1 2 3)` å½¢å¼ | `VoidV()` |
| **ç¬¦å·** | `SymbolV` | ç¬¦å·åç§° | `VoidV()` |

#### å®ç°ä»£ç 
```cpp
Value Display::evalRator(const Value &rand) {
    if (rand->v_type == V_STRING) {
        // å­—ç¬¦ä¸²ä¸æ˜¾ç¤ºå¼•å·
        String* str_ptr = dynamic_cast<String*>(rand.get());
        std::cout << str_ptr->s;
    } else {
        // å…¶ä»–ç±»å‹ä½¿ç”¨æ ‡å‡†æ˜¾ç¤ºæ–¹æ³•
        rand->show(std::cout);
    }
    
    return VoidV();
}
```

---

## å®Œæ•´è¾¹ç•Œæƒ…å†µæ€»ç»“è¡¨

### æŒ‰é”™è¯¯ç±»å‹åˆ†ç±»

#### ç±»å‹é”™è¯¯
| è¡¨è¾¾å¼ | é”™è¯¯è¾“å…¥ | é”™è¯¯ä¿¡æ¯ | è§£å†³æ–¹æ³• |
|--------|----------|----------|----------|
| **ç®—æœ¯è¿ç®—** | éæ•°å­—ç±»å‹ | `"Wrong typename"` | ç¡®ä¿æ“ä½œæ•°ä¸ºæ•°å­— |
| **æ¯”è¾ƒè¿ç®—** | éæ•°å­—ç±»å‹ | `"Wrong typename"` | ç¡®ä¿æ“ä½œæ•°ä¸ºæ•°å­— |
| **Car/Cdr** | éå¯¹å¶ç±»å‹ | `"Wrong typename"` | ç¡®ä¿æ“ä½œæ•°ä¸ºå¯¹å¶ |
| **Apply** | éè¿‡ç¨‹ç±»å‹ | `"Attempt to apply a non-procedure"` | ç¡®ä¿ç¬¬ä¸€ä¸ªå‚æ•°ä¸ºå‡½æ•° |

#### å‚æ•°é”™è¯¯
| è¡¨è¾¾å¼ | é”™è¯¯è¾“å…¥ | é”™è¯¯ä¿¡æ¯ | è§£å†³æ–¹æ³• |
|--------|----------|----------|----------|
| **Apply** | å‚æ•°ä¸ªæ•°ä¸åŒ¹é… | `"Wrong number of arguments"` | æ£€æŸ¥å‡½æ•°ç­¾å |
| **æ¯”è¾ƒè¿ç®—** | å‚æ•°è¿‡å°‘ | `"< requires at least 2 arguments"` | æä¾›è¶³å¤Ÿå‚æ•° |
| **å‡æ³•** | æ— å‚æ•° | `"Wrong number of arguments for -"` | è‡³å°‘æä¾›ä¸€ä¸ªå‚æ•° |

#### æ•°å­¦é”™è¯¯
| è¡¨è¾¾å¼ | é”™è¯¯è¾“å…¥ | é”™è¯¯ä¿¡æ¯ | è§£å†³æ–¹æ³• |
|--------|----------|----------|----------|
| **é™¤æ³•** | é™¤é›¶ | `"Division by zero"` | æ£€æŸ¥é™¤æ•°éé›¶ |
| **æŒ‡æ•°è¿ç®—** | è´ŸæŒ‡æ•° | `"Negative exponent not supported"` | ä½¿ç”¨éè´ŸæŒ‡æ•° |
| **æŒ‡æ•°è¿ç®—** | 0^0 | `"0^0 is undefined"` | é¿å…æ­¤æƒ…å†µ |

#### å˜é‡é”™è¯¯
| è¡¨è¾¾å¼ | é”™è¯¯è¾“å…¥ | é”™è¯¯ä¿¡æ¯ | è§£å†³æ–¹æ³• |
|--------|----------|----------|----------|
| **Var** | æœªå®šä¹‰å˜é‡ | `"undefined variable"` | å…ˆå®šä¹‰å˜é‡ |
| **Var** | éæ³•å˜é‡å | `"Wrong variable name"` | ä½¿ç”¨åˆæ³•æ ‡è¯†ç¬¦ |
| **Set!** | æœªå®šä¹‰å˜é‡ | `"Undefined variable in set!"` | å…ˆå®šä¹‰å†èµ‹å€¼ |

### æŒ‰æˆåŠŸæƒ…å†µåˆ†ç±»

#### æ€»æ˜¯æˆåŠŸçš„æ“ä½œ
- æ‰€æœ‰å­—é¢é‡æ±‚å€¼ï¼ˆFixnum, String, True, Falseï¼‰
- Quoteè¡¨è¾¾å¼ï¼ˆè¯­æ³•æ­£ç¡®çš„æƒ…å†µä¸‹ï¼‰
- Lambdaè¡¨è¾¾å¼åˆ›å»º
- MakeVoidã€Exit

#### å¯èƒ½å¤±è´¥çš„æ“ä½œ
- å˜é‡å¼•ç”¨ï¼ˆVarï¼‰
- å‡½æ•°è°ƒç”¨ï¼ˆApplyï¼‰
- ç®—æœ¯å’Œæ¯”è¾ƒè¿ç®—
- åˆ—è¡¨æ“ä½œï¼ˆcar, cdråœ¨éå¯¹å¶ä¸Šï¼‰
- å˜é‡èµ‹å€¼ï¼ˆset!ï¼‰

#### å¤æ‚æ§åˆ¶æµ
- Ifï¼šæ¡ä»¶æ±‚å€¼å¯èƒ½å¤±è´¥ï¼Œåˆ†æ”¯é€‰æ‹©æ€»æ˜¯æˆåŠŸ
- Condï¼šå„å­æ¡ä»¶æ±‚å€¼å¯èƒ½å¤±è´¥
- Beginï¼šä»»ä½•å­è¡¨è¾¾å¼å¤±è´¥éƒ½ä¼šå¯¼è‡´æ•´ä½“å¤±è´¥
- And/Orï¼šçŸ­è·¯æ±‚å€¼ï¼Œæå‰è¿”å›

---

## æ€§èƒ½å’Œå†…å­˜è€ƒè™‘

### æ ˆæº¢å‡ºé£é™©
| æ“ä½œ | é£é™©åœºæ™¯ | é¢„é˜²æªæ–½ |
|------|----------|----------|
| **é€’å½’è°ƒç”¨** | æ·±åº¦é€’å½’æ— ç»ˆæ­¢æ¡ä»¶ | æ£€æŸ¥é€’å½’æ·±åº¦ |
| **ç›¸äº’é€’å½’** | Aè°ƒç”¨Bï¼ŒBè°ƒç”¨A | æ­£ç¡®çš„ç»ˆæ­¢æ¡ä»¶ |
| **QuoteåµŒå¥—** | ææ·±çš„åµŒå¥—åˆ—è¡¨ | é™åˆ¶åµŒå¥—æ·±åº¦ |

### å†…å­˜æ³„æ¼é£é™©
| æ“ä½œ | é£é™©åœºæ™¯ | è§£å†³æ–¹æ¡ˆ |
|------|----------|----------|
| **é—­åŒ…åˆ›å»º** | å¤§é‡é—­åŒ…æ•è·å¤§ç¯å¢ƒ | æ™ºèƒ½æŒ‡é’ˆè‡ªåŠ¨ç®¡ç† |
| **ç¯å¢ƒæ‰©å±•** | é•¿æœŸå­˜åœ¨çš„å¤§ç¯å¢ƒ | åƒåœ¾å›æ”¶æœºåˆ¶ |
| **å¾ªç¯å¼•ç”¨** | ç¯å½¢æ•°æ®ç»“æ„ | å¼±å¼•ç”¨æˆ–æ‰‹åŠ¨æ‰“ç ´ |

---

## æ€»ç»“

è¿™ä¸ªåˆ†ææ¶µç›–äº†Schemeè§£é‡Šå™¨ä¸­æ‰€æœ‰è¡¨è¾¾å¼ç±»å‹çš„ï¼š

### âœ… å®Œæ•´æ€§
- **31ç§è¡¨è¾¾å¼ç±»å‹**ï¼šä»åŸºç¡€å­—é¢é‡åˆ°å¤æ‚æ§åˆ¶æµ
- **è¾¹ç•Œæƒ…å†µè¦†ç›–**ï¼šæˆåŠŸæƒ…å†µã€å¤±è´¥æƒ…å†µã€ç‰¹æ®Šæƒ…å†µ
- **é”™è¯¯å¤„ç†**ï¼šè¯¦ç»†çš„é”™è¯¯ç±»å‹å’Œå¤„ç†ç­–ç•¥

### âœ… å®ç”¨æ€§
- **è¯­æ³•ç¤ºä¾‹**ï¼šæ¯ç§æƒ…å†µéƒ½æœ‰å…·ä½“çš„ä»£ç ç¤ºä¾‹
- **å®ç°ç»†èŠ‚**ï¼šå…³é”®ä»£ç ç‰‡æ®µå’Œç®—æ³•é€»è¾‘
- **è°ƒè¯•æŒ‡å¯¼**ï¼šé”™è¯¯ä¿¡æ¯å’Œè§£å†³æ–¹æ³•

### âœ… ç³»ç»Ÿæ€§
- **åˆ†ç±»ç»„ç»‡**ï¼šæŒ‰åŠŸèƒ½é¢†åŸŸç³»ç»Ÿåˆ†ç±»
- **äº¤å‰å¼•ç”¨**ï¼šç›¸å…³åŠŸèƒ½ä¹‹é—´çš„å…³è”åˆ†æ
- **æ€§èƒ½è€ƒè™‘**ï¼šå†…å­˜å’Œæ ˆæº¢å‡ºç­‰å®é™…é—®é¢˜

è¿™ä¸ªæ–‡æ¡£ä¸ºç†è§£å’Œä½¿ç”¨Schemeè§£é‡Šå™¨æä¾›äº†å…¨é¢çš„æŠ€æœ¯å‚è€ƒï¼Œæ¶µç›–äº†ä»åŸºç¡€æ“ä½œåˆ°é«˜çº§ç‰¹æ€§çš„æ‰€æœ‰è¾¹ç•Œæƒ…å†µå’Œå®ç°ç»†èŠ‚ã€‚
